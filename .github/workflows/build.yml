name: Build/release

on:
  push:
    branches:
      - "**"
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, Tag oder Commit, der gebaut werden soll"
        required: false
        default: main
      release_tag:
        description: "Release-Tag (z. B. v1.2.3). Wenn leer, wird bei Tag-Push automatisch übernommen."
        required: false
      prerelease:
        description: "Release als Pre-Release markieren"
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.meta.outputs.should_release }}
      release_tag: ${{ steps.meta.outputs.release_tag }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
      checkout_ref: ${{ steps.meta.outputs.checkout_ref }}
    steps:
      - name: Parameter auswerten
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          event="${{ github.event_name }}"
          ref="${{ github.ref }}"
          input_ref="${{ github.event.inputs.ref }}"
          input_tag="${{ github.event.inputs.release_tag }}"
          input_prerelease="${{ github.event.inputs.prerelease }}"

          checkout_ref="$ref"
          should_release="false"
          release_tag=""
          prerelease="false"

          if [[ "$event" == "workflow_dispatch" && -n "$input_ref" ]]; then
            checkout_ref="$input_ref"
          fi

          if [[ "$ref" == refs/tags/* ]]; then
            should_release="true"
            release_tag="${ref#refs/tags/}"
            checkout_ref="$release_tag"  # Use tag name directly
          elif [[ "$event" == "workflow_dispatch" && -n "$input_tag" ]]; then
            should_release="true"
            release_tag="$input_tag"
            checkout_ref="$input_tag"
          fi

          if [[ "$should_release" == "true" ]]; then
            if [[ "$release_tag" == *-* ]]; then
              prerelease="true"
            fi
          fi
          if [[ "$input_prerelease" == "true" ]]; then
            prerelease="true"
          fi

          echo "should_release=$should_release" >> "$GITHUB_OUTPUT"
          echo "release_tag=$release_tag" >> "$GITHUB_OUTPUT"
          echo "prerelease=$prerelease" >> "$GITHUB_OUTPUT"
          echo "checkout_ref=$checkout_ref" >> "$GITHUB_OUTPUT"

  release:
    needs: prepare-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.checkout_ref }}
          fetch-depth: 0
          fetch-tags: true

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          CI: true

      - name: Build Windows Portable
        run: npx electron-builder --win portable --x64 --publish never
        env:
          CI: true
          CSC_IDENTITY_AUTO_DISCOVERY: false

      - name: Build Windows NSIS Installer
        run: npx electron-builder --win nsis --x64 --publish never
        env:
          CI: true
          CSC_IDENTITY_AUTO_DISCOVERY: false

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-release
          path: |
            release/build/*.exe
            release/build/*.yml
          retention-days: 30

      - name: Create GitHub Release and Upload Assets
        if: needs.prepare-release.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          tag="${{ needs.prepare-release.outputs.release_tag }}"
          
          # Create draft release if it doesn't exist
          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --draft --title "$tag" --notes "Release $tag"
          fi
          
          # Upload all exe files
          for file in release/build/*.exe; do
            if [ -f "$file" ]; then
              echo "Uploading $file..."
              gh release upload "$tag" "$file" --clobber
            fi
          done

  finalize-release:
    needs: [prepare-release, release]
    if: needs.prepare-release.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.checkout_ref }}
          fetch-depth: 0
          fetch-tags: true  # Fetch all tags for changelog generation

      - name: Generate Changelog and Finalize Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare-release.outputs.release_tag }}"
          prerelease="${{ needs.prepare-release.outputs.prerelease }}"
          release_flag=""
          if [[ "$prerelease" == "true" ]]; then
            release_flag="--prerelease"
          fi

          REPO="${{ github.repository }}"
          REPO_URL="https://github.com/$REPO"

          # Find previous release tag
          previous_tag=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | grep -v "^$tag$" | head -n 1 || echo "")
          
          echo "Current tag: $tag"
          echo "Previous tag: $previous_tag"

          # Function to format commits with PR/issue links
          format_commits() {
            local commits="$1"
            local formatted=""
            while IFS= read -r line; do
              if [[ -z "$line" ]]; then continue; fi
              # Extract PR number if present (e.g., "(#123)" or "PR #123")
              if [[ "$line" =~ \#([0-9]+) ]]; then
                pr_num="${BASH_REMATCH[1]}"
                # Format as linked item
                commit_msg=$(echo "$line" | sed -E 's/- //' | sed -E 's/\(#[0-9]+\)//' | sed -E 's/\([a-f0-9]+\)$//' | xargs)
                formatted+="- $commit_msg [#$pr_num]($REPO_URL/issues/$pr_num)\n"
              else
                # Format without PR link, but with commit hash link
                if [[ "$line" =~ \(([a-f0-9]+)\)$ ]]; then
                  hash="${BASH_REMATCH[1]}"
                  commit_msg=$(echo "$line" | sed -E 's/- //' | sed -E 's/\([a-f0-9]+\)$//' | xargs)
                  formatted+="- $commit_msg [\`$hash\`]($REPO_URL/commit/$hash)\n"
                else
                  formatted+="$line\n"
                fi
              fi
            done <<< "$commits"
            echo -e "$formatted"
          }

          # Generate changelog
          changelog=""
          
          if [[ -n "$previous_tag" ]]; then
            echo "Generating changelog from $previous_tag to $tag"
            
            # Get commits between tags, grouped by type
            features=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^feat" --regexp-ignore-case 2>/dev/null || echo "")
            fixes=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^fix" --regexp-ignore-case 2>/dev/null || echo "")
            docs=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^docs" --regexp-ignore-case 2>/dev/null || echo "")
            refactor=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^refactor" --regexp-ignore-case 2>/dev/null || echo "")
            perf=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^perf" --regexp-ignore-case 2>/dev/null || echo "")
            deps=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^deps\|^chore.*dep\|upgrade\|bump" --regexp-ignore-case 2>/dev/null || echo "")
            chore=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^chore" --regexp-ignore-case 2>/dev/null | grep -vi "dep\|upgrade\|bump" || echo "")
            build=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^build\|^ci" --regexp-ignore-case 2>/dev/null || echo "")
            
            # Build changelog with sections (Spring Framework style)
            changelog=":sparkles: **What's Changed**\n\n"
            changelog+="See [$tag Release Notes]($REPO_URL/releases/tag/$tag) for details.\n\n"
            
            if [[ -n "$features" ]]; then
              changelog+="## :rocket: New Features\n$(format_commits "$features")\n"
            fi
            
            if [[ -n "$fixes" ]]; then
              changelog+="## :lady_beetle: Bug Fixes\n$(format_commits "$fixes")\n"
            fi
            
            if [[ -n "$perf" ]]; then
              changelog+="## :zap: Performance Improvements\n$(format_commits "$perf")\n"
            fi
            
            if [[ -n "$refactor" ]]; then
              changelog+="## :recycle: Refactoring\n$(format_commits "$refactor")\n"
            fi
            
            if [[ -n "$docs" ]]; then
              changelog+="## :notebook_with_decorative_cover: Documentation\n$(format_commits "$docs")\n"
            fi
            
            if [[ -n "$deps" ]]; then
              changelog+="## :hammer: Dependency Upgrades\n$(format_commits "$deps")\n"
            fi
            
            if [[ -n "$build" ]]; then
              changelog+="## :wrench: Build & CI\n$(format_commits "$build")\n"
            fi
            
            if [[ -n "$chore" ]]; then
              changelog+="## :broom: Maintenance\n$(format_commits "$chore")\n"
            fi
            
            # Add comparison link
            changelog+="\n---\n**Full Changelog**: [$previous_tag...$tag]($REPO_URL/compare/$previous_tag...$tag)"
          else
            echo "No previous tag found, using GitHub's auto-generated notes"
            # Fallback to GitHub's generated notes for first release
            changelog=$(gh api repos/$REPO/releases/generate-notes -f tag_name="$tag" --jq '.body' 2>/dev/null || echo ":tada: Initial Release")
          fi

          # Create or update release
          if gh release view "$tag" >/dev/null 2>&1; then
            echo "Updating existing release $tag"
            gh release edit "$tag" --draft --title "$tag"
          else
            echo "Creating new release $tag"
            gh release create "$tag" --draft --title "$tag"
          fi

          # Apply changelog and finalize
          echo -e "$changelog" | gh release edit "$tag" --notes-file - $release_flag --draft=false
          
          echo "✅ Release $tag finalized successfully!"
