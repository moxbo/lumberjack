name: Build/release

on:
  push:
    branches:
      - "**"
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, Tag oder Commit, der gebaut werden soll"
        required: false
        default: main
      release_tag:
        description: "Release-Tag (z. B. v1.2.3). Wenn leer, wird bei Tag-Push automatisch übernommen."
        required: false
      prerelease:
        description: "Release als Pre-Release markieren"
        required: false
        type: boolean
        default: false
      promote_to_release:
        description: "Existierendes Pre-Release zu Release promoten (nur release_tag angeben)"
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.meta.outputs.should_release }}
      release_tag: ${{ steps.meta.outputs.release_tag }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
      checkout_ref: ${{ steps.meta.outputs.checkout_ref }}
      promote_only: ${{ steps.meta.outputs.promote_only }}
    steps:
      - name: Parameter auswerten
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          event="${{ github.event_name }}"
          ref="${{ github.ref }}"
          input_ref="${{ github.event.inputs.ref }}"
          input_tag="${{ github.event.inputs.release_tag }}"
          input_prerelease="${{ github.event.inputs.prerelease }}"
          input_promote="${{ github.event.inputs.promote_to_release }}"

          checkout_ref="$ref"
          should_release="false"
          release_tag=""
          prerelease="false"
          promote_only="false"

          if [[ "$event" == "workflow_dispatch" && -n "$input_ref" ]]; then
            checkout_ref="$input_ref"
          fi

          if [[ "$ref" == refs/tags/* ]]; then
            should_release="true"
            release_tag="${ref#refs/tags/}"
            checkout_ref="$ref"  # Use full refs/tags/... path for checkout
          elif [[ "$event" == "workflow_dispatch" && -n "$input_tag" ]]; then
            should_release="true"
            release_tag="$input_tag"
            # For manual dispatch, use the branch/ref (tag may not exist yet)
            if [[ -n "$input_ref" ]]; then
              checkout_ref="$input_ref"
            else
              checkout_ref="main"
            fi
          fi

          if [[ "$should_release" == "true" ]]; then
            if [[ "$release_tag" == *-* ]]; then
              prerelease="true"
            fi
          fi
          if [[ "$input_prerelease" == "true" ]]; then
            prerelease="true"
          fi

          # Check if we are promoting a pre-release to a release
          if [[ "$input_promote" == "true" && -n "$input_tag" ]]; then
            should_release="true"
            release_tag="$input_tag"
            prerelease="false"  # Force to non-prerelease
            promote_only="true"  # Skip build, only update release
          fi

          echo "should_release=$should_release" >> "$GITHUB_OUTPUT"
          echo "release_tag=$release_tag" >> "$GITHUB_OUTPUT"
          echo "prerelease=$prerelease" >> "$GITHUB_OUTPUT"
          echo "checkout_ref=$checkout_ref" >> "$GITHUB_OUTPUT"
          echo "promote_only=$promote_only" >> "$GITHUB_OUTPUT"

      - name: Checkout for release creation
        if: ${{ steps.meta.outputs.should_release == 'true' && steps.meta.outputs.promote_only != 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.meta.outputs.checkout_ref }}
          fetch-depth: 0
          fetch-tags: true

      - name: Create tag and draft GitHub Release (once)
        if: ${{ steps.meta.outputs.should_release == 'true' && steps.meta.outputs.promote_only != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.meta.outputs.release_tag }}"
          prerelease_flag=""
          if [[ "${{ steps.meta.outputs.prerelease }}" == "true" ]]; then
            prerelease_flag="--prerelease"
          fi

          # Create tag if it doesn't exist (for workflow_dispatch)
          if ! git rev-parse "$tag" >/dev/null 2>&1; then
            echo "Creating tag $tag..."
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$tag" -m "Release $tag"
            git push origin "$tag"
          fi

          # Create draft release if it doesn't exist
          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --draft --title "$tag" --notes "Release $tag"
          fi

  release:
    needs: prepare-release
    if: needs.prepare-release.outputs.promote_only != 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest]
        arch: [x64, ia32]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.checkout_ref }}
          fetch-depth: 0
          fetch-tags: true

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Update version in package.json
        if: needs.prepare-release.outputs.should_release == 'true'
        shell: bash
        run: |
          tag="${{ needs.prepare-release.outputs.release_tag }}"
          # Remove 'v' prefix if present (v1.0.0 -> 1.0.0)
          version="${tag#v}"
          echo "Setting version to $version"
          npm version "$version" --no-git-tag-version --allow-same-version
          
          # Also update release/app/package.json if it exists
          if [ -f "release/app/package.json" ]; then
            cd release/app
            npm version "$version" --no-git-tag-version --allow-same-version
            cd ../..
          fi

      - name: Build application
        run: npm run build
        env:
          CI: true

      - name: Build Windows Portable
        run: npx electron-builder --win portable --${{ matrix.arch }} --publish never
        env:
          CI: true
          CSC_IDENTITY_AUTO_DISCOVERY: false

      - name: Build Windows NSIS Installer
        if: ${{ matrix.arch == 'x64' }}
        run: npx electron-builder --win nsis --x64 --publish never
        env:
          CI: true
          CSC_IDENTITY_AUTO_DISCOVERY: false

      - name: Organize build outputs into arch subfolder
        if: always()
        shell: pwsh
        run: |
          $arch = "${{ matrix.arch }}"
          $outDir = Join-Path $PWD "release\build"
          $archDir = Join-Path $outDir $arch
          if (-not (Test-Path $archDir)) { New-Item -ItemType Directory -Path $archDir | Out-Null }
          $moved = 0
          Get-ChildItem -Path $outDir -File -Force -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*$arch*" } | ForEach-Object {
            Move-Item -Path $_.FullName -Destination $archDir -Force
            $moved += 1
          }
          if (Test-Path (Join-Path $outDir 'win-unpacked')) {
            $dest = Join-Path $archDir 'win-unpacked'
            # Move win-unpacked directory into arch folder (if present)
            Move-Item -Path (Join-Path $outDir 'win-unpacked') -Destination $dest -Force -ErrorAction SilentlyContinue
          }
          Write-Host "Moved $moved files into $archDir"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-release-${{ matrix.arch }}
          path: |
            release/build/${{ matrix.arch }}/*.exe
            release/build/${{ matrix.arch }}/*.yml
            release/build/${{ matrix.arch }}/*.blockmap
          retention-days: 30

      - name: Create GitHub Release and Upload Assets
        if: needs.prepare-release.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ARCH: ${{ matrix.arch }}
        shell: bash
        run: |
          tag="${{ needs.prepare-release.outputs.release_tag }}"
          
          # Upload only files matching current ARCH
          echo "Uploading artifacts for ARCH=$ARCH"
          matches=0
          for file in release/build/"$ARCH"/*; do
            if [ -f "$file" ]; then
              echo "Uploading $file..."
              gh release upload "$tag" "$file" --clobber || true
              matches=$((matches+1))
            fi
          done
          if [ "$matches" -eq 0 ]; then
            echo "No artifacts found for arch=$ARCH, skipping upload."
          fi

  finalize-release:
    needs: [prepare-release, release]
    if: always() && needs.prepare-release.outputs.should_release == 'true' && (needs.release.result == 'success' || needs.prepare-release.outputs.promote_only == 'true')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.checkout_ref }}
          fetch-depth: 0
          fetch-tags: true  # Fetch all tags for changelog generation

      - name: Generate Changelog and Finalize Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare-release.outputs.release_tag }}"
          prerelease="${{ needs.prepare-release.outputs.prerelease }}"
          release_flag=""
          if [[ "$prerelease" == "true" ]]; then
            release_flag="--prerelease"
          fi

          REPO="${{ github.repository }}"
          REPO_URL="https://github.com/$REPO"

          # Find previous release tag
          previous_tag=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | grep -v "^$tag$" | head -n 1 || echo "")
          
          echo "Current tag: $tag"
          echo "Previous tag: $previous_tag"

          # Function to format commits with PR/issue links
          format_commits() {
            local commits="$1"
            local formatted=""
            while IFS= read -r line; do
              if [[ -z "$line" ]]; then continue; fi
              # Extract PR number if present (e.g., "(#123)" or "PR #123")
              if [[ "$line" =~ \#([0-9]+) ]]; then
                pr_num="${BASH_REMATCH[1]}"
                # Format as linked item
                commit_msg=$(echo "$line" | sed -E 's/- //' | sed -E 's/\(#[0-9]+\)//' | sed -E 's/\([a-f0-9]+$//' | xargs)
                formatted+="- $commit_msg [#$pr_num]($REPO_URL/issues/$pr_num)\n"
              else
                # Format without PR link, but with commit hash link
                if [[ "$line" =~ \(([a-f0-9]+)\)$ ]]; then
                  hash="${BASH_REMATCH[1]}"
                  commit_msg=$(echo "$line" | sed -E 's/- //' | sed -E 's/\([a-f0-9]+\)$//' | xargs)
                  formatted+="- $commit_msg [\`$hash\`]($REPO_URL/commit/$hash)\n"
                else
                  formatted+="$line\n"
                fi
              fi
            done <<< "$commits"
            echo -e "$formatted"
          }

          # Generate changelog
          changelog=""
          
          if [[ -n "$previous_tag" ]]; then
            echo "Generating changelog from $previous_tag to $tag"
            
            # Get commits between tags, grouped by type
            features=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^feat" --regexp-ignore-case 2>/dev/null || echo "")
            fixes=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^fix" --regexp-ignore-case 2>/dev/null || echo "")
            docs=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^docs" --regexp-ignore-case 2>/dev/null || echo "")
            refactor=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^refactor" --regexp-ignore-case 2>/dev/null || echo "")
            perf=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^perf" --regexp-ignore-case 2>/dev/null || echo "")
            deps=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^deps\|^chore.*dep\|upgrade\|bump" --regexp-ignore-case 2>/dev/null || echo "")
            chore=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^chore" --regexp-ignore-case 2>/dev/null | grep -vi "dep\|upgrade\|bump" || echo "")
            build=$(git log "$previous_tag..$tag" --pretty=format:"- %s (%h)" --grep="^build\|^ci" --regexp-ignore-case 2>/dev/null || echo "")
            
            # Build changelog with sections (Spring Framework style)
            changelog=":sparkles: **What's Changed**\n\n"
            changelog+="See [$tag Release Notes]($REPO_URL/releases/tag/$tag) for details.\n\n"
            
            if [[ -n "$features" ]]; then
              changelog+="## :rocket: New Features\n$(format_commits "$features")\n"
            fi
            
            if [[ -n "$fixes" ]]; then
              changelog+="## :lady_beetle: Bug Fixes\n$(format_commits "$fixes")\n"
            fi
            
            if [[ -n "$perf" ]]; then
              changelog+="## :zap: Performance Improvements\n$(format_commits "$perf")\n"
            fi
            
            if [[ -n "$refactor" ]]; then
              changelog+="## :recycle: Refactoring\n$(format_commits "$refactor")\n"
            fi
            
            if [[ -n "$docs" ]]; then
              changelog+="## :notebook_with_decorative_cover: Documentation\n$(format_commits "$docs")\n"
            fi
            
            if [[ -n "$deps" ]]; then
              changelog+="## :hammer: Dependency Upgrades\n$(format_commits "$deps")\n"
            fi
            
            if [[ -n "$build" ]]; then
              changelog+="## :wrench: Build & CI\n$(format_commits "$build")\n"
            fi
            
            if [[ -n "$chore" ]]; then
              changelog+="## :broom: Maintenance\n$(format_commits "$chore")\n"
            fi
            
            # Add comparison link
            changelog+="\n---\n**Full Changelog**: [$previous_tag...$tag]($REPO_URL/compare/$previous_tag...$tag)"
          else
            echo "No previous tag found, using GitHub's auto-generated notes"
            # Fallback to GitHub's generated notes for first release
            changelog=$(gh api repos/$REPO/releases/generate-notes -f tag_name="$tag" --jq '.body' 2>/dev/null || echo ":tada: Initial Release")
          fi

          # Create or update release
          if gh release view "$tag" >/dev/null 2>&1; then
            echo "Updating existing release $tag"
            gh release edit "$tag" --draft --title "$tag"
          else
            echo "Creating new release $tag"
            gh release create "$tag" --draft --title "$tag"
          fi

          # Apply changelog and finalize
          echo -e "$changelog" | gh release edit "$tag" --notes-file - $release_flag --draft=false
          
          echo "✅ Release $tag finalized successfully!"
